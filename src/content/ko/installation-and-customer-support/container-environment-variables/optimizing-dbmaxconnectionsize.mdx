---
title: 'DB_MAX_CONNECTION_SIZE 최적화'
---

# DB_MAX_CONNECTION_SIZE 최적화

### Overview

QueryPie MySQL 연결 설정에 사용되는 Database Connection Pool Size 를 최적화하는 방법을 안내합니다.

#### QueryPie MySQL 의 구성

QueryPie Server 는 MySQL Database 에 Meta DB, Snapshot DB, Log DB 를 구성하여 작동합니다.

* Meta DB : 이용자 계정, 연결 설정, 접근 제어 정책 등 QueryPie Web Console 에서 제공하는 기능을 위한 데이터가 Meta DB 에 저장됩니다.
* Snapshot DB : SQL 쿼리 실행과정에서 Audit Log 를 기록하기 위해 일시적으로 사용하는 데이터 저장소입니다.
* Log DB : 이용자의 접근 기록, SQL 실행 기록 등 감사 로그(Audit Log)를 저장하는 데이터 저장소입니다.

QueryPie Server 는 Spring framework 를 사용하는 컴포넌트를 갖고 있으며, 이 컴포넌트에서는 Database Connection Pool 을 구성하여, QueryPie MySQL 에 데이터를 저장합니다.

### Database Connection Pool Size 설정하기

QueryPie Server Container 를 실행할 때, 환경변수를 이용하여, Database Connection Pool Size 를 설정할 수 있습니다.

#### `DB_MAX_CONNECTION_SIZE`

Meta DB 를 위한 DB Connection Pool Size 를 지정합니다.
기본값은 20 입니다.

#### `LOG_DB_MAX_CONNECTION_SIZE`

Log DB 를 위한 DB Connection Pool Size 를 지정합니다.
기본값은 `DB_MAX_CONNECTION_SIZE` 에 설정된 값입니다.
별도로 `LOG_DB_MAX_CONNECTION_SIZE` 를 설정하지 않으면, `DB_MAX_CONNECTION_SIZE` 의 값과 동일한 값이 설정됩니다.

Snapshot DB 의 Connection Pool Size 는 이용자가 제어할 필요성이 낮아서, 이 값을 제어하기 위한 환경변수를 제공하지 않습니다.

### 일반적인 이용자 사용량, 부하 발생의 경우

`DB_MAX_CONNECTION_SIZE` 의 기본값 20 을 그대로 사용하는 것을 권장합니다.
일반적인 경우에 두루 사용할 수 있는 Connection Pool Size 의 크기입니다.
PoC 환경 뿐만 아니라, 일반적인 Production 환경에서 충분히 처리성능을 낼 수 있는 수치를 기본값으로 권장하고 있습니다.

### 많은 사용량, 높은 부하 발생의 경우

`DB_MAX_CONNECTION_SIZE` 의 값을 20~40 사이의 값으로 설정하는 것을 권장합니다.
적정한 범위 내에서 `DB_MAX_CONNECTION_SIZE` 가 높아지면, QueryPie 가 동시에 처리 가능한 부하의 양이 늘어납니다.

DB 서버의 처리성능이 높고, CPU 수가 많은 경우, `DB_MAX_CONNECTION_SIZE` 를 높입니다.
Server Container 가 작동하는 Linux VM 의 처리성능이 높고, CPU 수가 많은 경우, `DB_MAX_CONNECTION_SIZE` 를 높입니다.
Server Container 의 수가 늘어나면, `DB_MAX_CONNECTION_SIZE` 를 낮춥니다.

### `DB_MAX_CONNECTION_SIZE`설정값 요약표

|  **DB_MAX_CONNECTION_SIZE**  |  **Description**                                                                 |
| ---------------------------- | -------------------------------------------------------------------------------- |
| 40                           | MySQL DB 의 처리량이 많고, 고사양 하드웨어 처리성능을 가진 경우에 적합합니다. 40보다 높은 설정값을 사용하는 것은 권장하지 않습니다. |
| 30                           | MySQL DB 의 처리량이 많고, 고사양 하드웨어 처리성능을 가진 경우에 적합합니다.                                 |
|  **20**                      |  **운영 환경에 적합한 권장값입니다. 범용적으로 많은 요청을 처리할 수 있는 설정값입니다.**                            |
| 10                           | 운영 환경에서, MySQL 연결수를 줄이고자 하는 경우에 적합합니다.                                           |
| 5                            | PoC 에서 기능 테스트를 수행하는 경우, 운영 환경에서 사용자 수가 적은 경우에 적합합니다.                             |

### `DB_MAX_CONNECTION_SIZE`와 하드웨어 용량의 관계식

개발팀 내부의 성능 최적화 테스트를 통해, `DB_MAX_CONNECTION_SIZE` 과 QueryPie Server VM, DB 의 하드웨어 처리용량 사이에 다음의 관계식이 있다는 것을 도출하였습니다.
이 관계식을 참조하여, `DB_MAX_CONNECTION_SIZE` 값을 설정하면, 최적의 처리성능을 얻는 동시에, 가능한 작은 `DB_MAX_CONNECTION_SIZE` 값을 설정할 수 있습니다.

#### QueryPie MySQL 을 분리구성하는 경우

하나의 Linux VM 내에 QueryPie Server Container 와 QueryPie MySQL 을 함께 실행하지 않고, 별도의 VM 또는 Cloud Service 를 이용해, 분리된 MySQL Instance 를 구성하는 경우입니다.
Production 환경에 적용하는 것을 권장합니다.

`DB_MAX_CONNECTION_SIZE` = `minimum ( Application_CPU_Count / Application_Node_Count, RDS_CPU_Count ) * 10`

* Application_CPU_Count - QueryPie Server Container 가 실행되는 Linux VM 의 vCPU 갯수
* Application_Node_Count - QueryPie Server Container 의 갯수, 또는 실행되는 Linux VM 의 갯수, 또는 Kubernetes Pod 의 갯수.
    * 이중화 구성의 경우, 2, 삼중화 구성의 경우, 3 이 됩니다.
* RDS_CPU_Count - 별도로 구성된 QueryPie MySQL 이 실행되는 VM Instance 의 vCPU 갯수
* minimum ( a, b, c, … ) - `,` 로 구분된 여러 값 가운데, 가장 작은 값을 선택합니다.

예시1) Server Container 가 실행되는 Linux 의 VM 이 4 vCPU 이고, 2개의 Linux VM 을 운영합니다.
AWS Aurora MySQL 이 4 vCPU 입니다.
```
minimum ( Application_CPU_Count / Application_Node_Count, RDS_CPU_Count ) * 10
= minimum ( 4 / 2, 4 ) * 10
= 2 * 10
= 20
```

예시2) Server Container 가 실행되는 Linux 의 VM 이 8 vCPU 이고, 3개의 Linux VM 을 운영합니다.
AWS Aurora MySQL 이 8 vCPU 입니다.
```
minimum ( Application_CPU_Count / Application_Node_Count, RDS_CPU_Count ) * 10
= minimum ( 8 / 3, 8 ) * 10
= 2.66 * 10
= 27
```

#### 단일 Linux VM 구성의 경우

하나의 Linux VM 에 QueryPie Server Container, QueryPie MySQL 을 함께 실행하는 경우입니다.
PoC 환경에 사용하는 것이 적합합니다.

`DB_MAX_CONNECTION_SIZE` = `Application_CPU_Count * 2.5`

* Application_CPU_Count - QueryPie Server Container 가 실행되는 Linux VM 의 vCPU 갯수

예시1) Server Container 가 실행되는 Linux 의 VM 이 4 vCPU 이고, MySQL 을 함께 실행합니다.
이 경우, `DB_MAX_CONNECTION_SIZE` 을 10 으로 설정하는 것이 적절합니다.
```
Application_CPU_Count * 2.5
= 4 * 2.5
= 10
```


### QueryPie MySQL 설정에서 충분한 연결수를 허용하기

QueryPie Server 는 Connection Pool 을 이용하여 QueryPie MySQL 에 연결을 맺습니다.
만일, MySQL Database Server 가 충분한 연결수를 허용하지 않는 경우, QueryPie Server 가 MySQL 에 연결을 생성하지 못하고, 오작동하는 현상이 발생하게 됩니다.
이 문제 현상은 QueryPie MySQL 가 허용하는 연결수보다, QueryPie Server 가 요구하는 DB 연결수가 더 큰 경우에 발생합니다.

#### DB 연결을 생성하지 못하는 현상

Web Console 에서, `[API] Could not open JPA EntityManager for transaction` 라는 에러 메시지를 만나게 됩니다.

<figure data-layout="center" data-align="center">
![[API] Could not open JPA EntityManager for transaction](/installation-and-customer-support/container-environment-variables/optimizing-dbmaxconnectionsize/Screenshot-2025-04-24-at-9.38.20-PM.png)
<figcaption>
[API] Could not open JPA EntityManager for transaction
</figcaption>
</figure>


#### 문제해결방법 1) QueryPie MySQL 이 허용하는 연결수를 늘이기

두 가지 설정값을 500 이상으로 늘이는 설정을 적용할 수 있습니다.
이를 통해, QueryPie Server 가 요구하는 DB 연결수보다, QueryPie MySQL 가 허용하는 연결수를 더 크게 설정할 수 있습니다.

* MAX_USER_CONNECTIONS 
    * [https://dev.mysql.com/doc/refman/8.0/en/user-resources.html](https://dev.mysql.com/doc/refman/8.0/en/user-resources.html)
    * `ALTER USER 'querypie'@'%' WITH MAX_USER_CONNECTIONS 500;`
* max_connections
    * [https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections](https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_max_connections)

#### 문제해결방법 2) DB_MAX_CONNECTION_SIZE 를 줄이기

QueryPie 이용자 수가 적고, 이용량 부하가 낮은 경우, `DB_MAX_CONNECTION_SIZE` 설정값을 줄일 수 있습니다.
이를 통해, QueryPie MySQL 가 허용하는 연결수보다, QueryPie Server 가 요구하는 DB 연결수를 더 작게 설정할 수 있습니다.

`DB_MAX_CONNECTION_SIZE` 를 기본값 20이 아닌, 10 또는 5 로 낮추어 설정합니다.
PoC 환경의 경우, `DB_MAX_CONNECTION_SIZE` 를 5 로 설정하여도, 일반적인 기능 테스트를 원활히 수행할 수 있습니다.


